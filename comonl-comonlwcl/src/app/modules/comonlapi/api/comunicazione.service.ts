/**
 * ComonlWeb
 * API per ComonlWeb
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApiError } from '../model/apiError';
import { Comunicazione } from '../model/comunicazione';
import { ComunicazioneUrgHolder } from '../model/comunicazioneUrgHolder';
import { Datore } from '../model/datore';
import { FormRecuperoComunicazione } from '../model/formRecuperoComunicazione';
import { FormRicercaComunicazione } from '../model/formRicercaComunicazione';
import { PagedResponseRicercaComunicazioni } from '../model/pagedResponseRicercaComunicazioni';
import { PagedResponseRicercaVardatori } from '../model/pagedResponseRicercaVardatori';
import { Rapporto } from '../model/rapporto';
import { RecuperoComunicazione } from '../model/recuperoComunicazione';
import { Tutore } from '../model/tutore';
import { WrapperComunicazione } from '../model/wrapperComunicazione';
import { WrapperRapporto } from '../model/wrapperRapporto';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration, FormParams }                         from '../configuration';
import { ComunicazioneServiceInterface }                            from './comunicazione.serviceInterface';


@Injectable()
export class ComunicazioneService implements ComunicazioneServiceInterface {

    protected basePath = 'http://localhost:8080/comonlweb/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Cancel Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public annullaComunicazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public annullaComunicazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public annullaComunicazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public annullaComunicazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Comunicazione>(`${this.basePath}/comunicazione/annulla`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public annullaComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public annullaComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public annullaComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public annullaComunicazioneVardatore(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Comunicazione>(`${this.basePath}/comunicazione/annulla-vardatore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancella Comunicazione
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancellaComunicazione(id: number, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public cancellaComunicazione(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public cancellaComunicazione(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public cancellaComunicazione(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cancellaComunicazione.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione/cancella/${encodeURIComponent(String(id))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Comunicazione
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComunicazioneById(id: number, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public getComunicazioneById(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public getComunicazioneById(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public getComunicazioneById(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getComunicazioneById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Comunicazione>(`${this.basePath}/comunicazione/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Comunicazione
     * 
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getComunicazioneUrgenzaHolderById(id: number, observe?: 'body', reportProgress?: boolean): Observable<ComunicazioneUrgHolder>;
    public getComunicazioneUrgenzaHolderById(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ComunicazioneUrgHolder>>;
    public getComunicazioneUrgenzaHolderById(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ComunicazioneUrgHolder>>;
    public getComunicazioneUrgenzaHolderById(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getComunicazioneUrgenzaHolderById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<ComunicazioneUrgHolder>(`${this.basePath}/comunicazione/urg-holder/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Invia Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public inviaComunicazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Array<Comunicazione>>;
    public inviaComunicazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Comunicazione>>>;
    public inviaComunicazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Comunicazione>>>;
    public inviaComunicazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<Comunicazione>>(`${this.basePath}/comunicazione/invia`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postComunicazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public postComunicazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public postComunicazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public postComunicazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Comunicazione>(`${this.basePath}/comunicazione`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Comunicazione di Urgenza
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postComunicazioneUrgenza(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public postComunicazioneUrgenza(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public postComunicazioneUrgenza(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public postComunicazioneUrgenza(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<number>(`${this.basePath}/comunicazione/urg`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Comunicazione vardatore
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public postComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public postComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public postComunicazioneVardatore(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Comunicazione>(`${this.basePath}/comunicazione/vardatore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Rapporto Missione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRapportoMissione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Rapporto>;
    public postRapportoMissione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rapporto>>;
    public postRapportoMissione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rapporto>>;
    public postRapportoMissione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Rapporto>(`${this.basePath}/comunicazione/rapporto-missione`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * recupero comunicazioni
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRecuperoComunicazioni(body?: FormRecuperoComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Array<RecuperoComunicazione>>;
    public postRecuperoComunicazioni(body?: FormRecuperoComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RecuperoComunicazione>>>;
    public postRecuperoComunicazioni(body?: FormRecuperoComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RecuperoComunicazione>>>;
    public postRecuperoComunicazioni(body?: FormRecuperoComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<RecuperoComunicazione>>(`${this.basePath}/comunicazione/recupero`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * ricerca comunicazioni
     * 
     * @param body 
     * @param offset 
     * @param limit 
     * @param sort 
     * @param direction 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaComunicazioni(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResponseRicercaComunicazioni>;
    public postRicercaComunicazioni(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseRicercaComunicazioni>>;
    public postRicercaComunicazioni(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseRicercaComunicazioni>>;
    public postRicercaComunicazioni(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseRicercaComunicazioni>(`${this.basePath}/comunicazione/ricerca`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * ricerca comunicazioni vardatori
     * 
     * @param body 
     * @param offset 
     * @param limit 
     * @param sort 
     * @param direction 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResponseRicercaComunicazioni>;
    public postRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseRicercaComunicazioni>>;
    public postRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseRicercaComunicazioni>>;
    public postRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseRicercaComunicazioni>(`${this.basePath}/comunicazione/ricercaVardatori`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * ricerca comunicazioni vardatori
     * 
     * @param body 
     * @param offset 
     * @param limit 
     * @param sort 
     * @param direction 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRicercaVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'body', reportProgress?: boolean): Observable<PagedResponseRicercaVardatori>;
    public postRicercaVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagedResponseRicercaVardatori>>;
    public postRicercaVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagedResponseRicercaVardatori>>;
    public postRicercaVardatori(body?: FormRicercaComunicazione, offset?: number, limit?: number, sort?: string, direction?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (direction !== undefined && direction !== null) {
            queryParameters = queryParameters.set('direction', <any>direction);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PagedResponseRicercaVardatori>(`${this.basePath}/comunicazione/ricerca-vardatori`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Tutore
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postTutore(body?: Comunicazione, observe?: 'body', reportProgress?: boolean): Observable<Tutore>;
    public postTutore(body?: Comunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tutore>>;
    public postTutore(body?: Comunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tutore>>;
    public postTutore(body?: Comunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Tutore>(`${this.basePath}/comunicazione/tutore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putComunicazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public putComunicazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public putComunicazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public putComunicazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Comunicazione di Urgenza
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putComunicazioneUrgenza(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public putComunicazioneUrgenza(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public putComunicazioneUrgenza(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public putComunicazioneUrgenza(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<number>(`${this.basePath}/comunicazione/urg`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put Comunicazione vardatore
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public putComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public putComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public putComunicazioneVardatore(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione/vardatore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put dati cessazione del rapporto
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putDatiCessazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public putDatiCessazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public putDatiCessazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public putDatiCessazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione/dati-cessazione`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put dati proroga del rapporto
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putDatiProroga(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public putDatiProroga(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public putDatiProroga(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public putDatiProroga(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione/dati-proroga`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put dati trasferimento e distacco
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putDatiTrasferimentoDistacco(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public putDatiTrasferimentoDistacco(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public putDatiTrasferimentoDistacco(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public putDatiTrasferimentoDistacco(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione/dati-trasferimento-distacco`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put dati trasformazione del rapporto
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putDatiTrasformazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public putDatiTrasformazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public putDatiTrasformazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public putDatiTrasformazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Comunicazione>(`${this.basePath}/comunicazione/dati-trasformazione`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post Rapporto Missione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putRapportoMissione(body?: WrapperRapporto, observe?: 'body', reportProgress?: boolean): Observable<Rapporto>;
    public putRapportoMissione(body?: WrapperRapporto, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rapporto>>;
    public putRapportoMissione(body?: WrapperRapporto, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rapporto>>;
    public putRapportoMissione(body?: WrapperRapporto, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Rapporto>(`${this.basePath}/comunicazione/rapporto-missione`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Put Tutore
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putTutore(body?: Comunicazione, observe?: 'body', reportProgress?: boolean): Observable<Tutore>;
    public putTutore(body?: Comunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tutore>>;
    public putTutore(body?: Comunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tutore>>;
    public putTutore(body?: Comunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Tutore>(`${this.basePath}/comunicazione/tutore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Rettifica Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rettificaComunicazione(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public rettificaComunicazione(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public rettificaComunicazione(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public rettificaComunicazione(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Comunicazione>(`${this.basePath}/comunicazione/rettifica`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Rettifica Comunicazione
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rettificaComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Comunicazione>;
    public rettificaComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Comunicazione>>;
    public rettificaComunicazioneVardatore(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Comunicazione>>;
    public rettificaComunicazioneVardatore(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Comunicazione>(`${this.basePath}/comunicazione/rettifica-vardatore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Ritrasmissioni commax
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public ritrasmettiComunicazioni(observe?: 'body', reportProgress?: boolean): Observable<string>;
    public ritrasmettiComunicazioni(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public ritrasmettiComunicazioni(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public ritrasmettiComunicazioni(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        return this.httpClient.post<string>(`${this.basePath}/comunicazione/ritrasmetti-comunicazioni`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Comunicazione
     * 
     * @param id 
     * @param operatoreProvinciale 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stampaComunicazioneById(id: number, operatoreProvinciale: boolean, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public stampaComunicazioneById(id: number, operatoreProvinciale: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public stampaComunicazioneById(id: number, operatoreProvinciale: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public stampaComunicazioneById(id: number, operatoreProvinciale: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling stampaComunicazioneById.');
        }
        if (operatoreProvinciale === null || operatoreProvinciale === undefined) {
            throw new Error('Required parameter operatoreProvinciale was null or undefined when calling stampaComunicazioneById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/pdf'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get(`${this.basePath}/comunicazione/stampa/${encodeURIComponent(String(id))}/${encodeURIComponent(String(operatoreProvinciale))}`,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * stampa ricerca comunicazioni
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stampaRicercaComunicazioni(body?: FormRicercaComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public stampaRicercaComunicazioni(body?: FormRicercaComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public stampaRicercaComunicazioni(body?: FormRicercaComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public stampaRicercaComunicazioni(body?: FormRicercaComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/pdf'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post(`${this.basePath}/comunicazione/stampa-ricerca-comunicazioni`,
            body,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * stampa ricerca comunicazioni vardatori
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stampaRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public stampaRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public stampaRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public stampaRicercaComunicazioniVardatori(body?: FormRicercaComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/pdf'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post(`${this.basePath}/comunicazione/stampa-ricerca-comunicazioni-vardatori`,
            body,
            {
                responseType: "blob",
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Upload per verifica file
     * 
     * @param attachment 
     * @param email 
     * @param nomeFile 
     * @param isVerifica 
     * @param ilRuolo 
     * @param codiceFiscaleUtente 
     * @param dsCognome 
     * @param dsNome 
     * @param codiceFiscaleAzienda 
     * @param consulenteRespo 
     * @param isAmministratore 
     * @param isOperatoreProvinciale 
     * @param isDelegatoRespo 
     * @param isLegaleRappresentante 
     * @param isPersonaAutorizzata 
     * @param emailRuolo 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadComunicazioni(attachment: Blob, email: string, nomeFile: string, isVerifica: boolean, ilRuolo: string, codiceFiscaleUtente: string, dsCognome: string, dsNome: string, codiceFiscaleAzienda: string, consulenteRespo: boolean, isAmministratore: boolean, isOperatoreProvinciale: boolean, isDelegatoRespo: boolean, isLegaleRappresentante: boolean, isPersonaAutorizzata: boolean, emailRuolo?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public uploadComunicazioni(attachment: Blob, email: string, nomeFile: string, isVerifica: boolean, ilRuolo: string, codiceFiscaleUtente: string, dsCognome: string, dsNome: string, codiceFiscaleAzienda: string, consulenteRespo: boolean, isAmministratore: boolean, isOperatoreProvinciale: boolean, isDelegatoRespo: boolean, isLegaleRappresentante: boolean, isPersonaAutorizzata: boolean, emailRuolo?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public uploadComunicazioni(attachment: Blob, email: string, nomeFile: string, isVerifica: boolean, ilRuolo: string, codiceFiscaleUtente: string, dsCognome: string, dsNome: string, codiceFiscaleAzienda: string, consulenteRespo: boolean, isAmministratore: boolean, isOperatoreProvinciale: boolean, isDelegatoRespo: boolean, isLegaleRappresentante: boolean, isPersonaAutorizzata: boolean, emailRuolo?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public uploadComunicazioni(attachment: Blob, email: string, nomeFile: string, isVerifica: boolean, ilRuolo: string, codiceFiscaleUtente: string, dsCognome: string, dsNome: string, codiceFiscaleAzienda: string, consulenteRespo: boolean, isAmministratore: boolean, isOperatoreProvinciale: boolean, isDelegatoRespo: boolean, isLegaleRappresentante: boolean, isPersonaAutorizzata: boolean, emailRuolo?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (attachment === null || attachment === undefined) {
            throw new Error('Required parameter attachment was null or undefined when calling uploadComunicazioni.');
        }
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling uploadComunicazioni.');
        }
        if (nomeFile === null || nomeFile === undefined) {
            throw new Error('Required parameter nomeFile was null or undefined when calling uploadComunicazioni.');
        }
        if (isVerifica === null || isVerifica === undefined) {
            throw new Error('Required parameter isVerifica was null or undefined when calling uploadComunicazioni.');
        }
        if (ilRuolo === null || ilRuolo === undefined) {
            throw new Error('Required parameter ilRuolo was null or undefined when calling uploadComunicazioni.');
        }
        if (codiceFiscaleUtente === null || codiceFiscaleUtente === undefined) {
            throw new Error('Required parameter codiceFiscaleUtente was null or undefined when calling uploadComunicazioni.');
        }
        if (dsCognome === null || dsCognome === undefined) {
            throw new Error('Required parameter dsCognome was null or undefined when calling uploadComunicazioni.');
        }
        if (dsNome === null || dsNome === undefined) {
            throw new Error('Required parameter dsNome was null or undefined when calling uploadComunicazioni.');
        }
        if (codiceFiscaleAzienda === null || codiceFiscaleAzienda === undefined) {
            throw new Error('Required parameter codiceFiscaleAzienda was null or undefined when calling uploadComunicazioni.');
        }
        if (consulenteRespo === null || consulenteRespo === undefined) {
            throw new Error('Required parameter consulenteRespo was null or undefined when calling uploadComunicazioni.');
        }
        if (isAmministratore === null || isAmministratore === undefined) {
            throw new Error('Required parameter isAmministratore was null or undefined when calling uploadComunicazioni.');
        }
        if (isOperatoreProvinciale === null || isOperatoreProvinciale === undefined) {
            throw new Error('Required parameter isOperatoreProvinciale was null or undefined when calling uploadComunicazioni.');
        }
        if (isDelegatoRespo === null || isDelegatoRespo === undefined) {
            throw new Error('Required parameter isDelegatoRespo was null or undefined when calling uploadComunicazioni.');
        }
        if (isLegaleRappresentante === null || isLegaleRappresentante === undefined) {
            throw new Error('Required parameter isLegaleRappresentante was null or undefined when calling uploadComunicazioni.');
        }
        if (isPersonaAutorizzata === null || isPersonaAutorizzata === undefined) {
            throw new Error('Required parameter isPersonaAutorizzata was null or undefined when calling uploadComunicazioni.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: FormParams;
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (attachment !== undefined) {
            formParams = formParams.append('attachment', <any>attachment) || formParams;
        }
        if (email !== undefined) {
            formParams = formParams.append('email', <any>email) || formParams;
        }
        if (nomeFile !== undefined) {
            formParams = formParams.append('nomeFile', <any>nomeFile) || formParams;
        }
        if (isVerifica !== undefined) {
            formParams = formParams.append('isVerifica', <any>isVerifica) || formParams;
        }
        if (ilRuolo !== undefined) {
            formParams = formParams.append('ilRuolo', <any>ilRuolo) || formParams;
        }
        if (codiceFiscaleUtente !== undefined) {
            formParams = formParams.append('codiceFiscaleUtente', <any>codiceFiscaleUtente) || formParams;
        }
        if (dsCognome !== undefined) {
            formParams = formParams.append('dsCognome', <any>dsCognome) || formParams;
        }
        if (dsNome !== undefined) {
            formParams = formParams.append('dsNome', <any>dsNome) || formParams;
        }
        if (codiceFiscaleAzienda !== undefined) {
            formParams = formParams.append('codiceFiscaleAzienda', <any>codiceFiscaleAzienda) || formParams;
        }
        if (consulenteRespo !== undefined) {
            formParams = formParams.append('consulenteRespo', <any>consulenteRespo) || formParams;
        }
        if (isAmministratore !== undefined) {
            formParams = formParams.append('isAmministratore', <any>isAmministratore) || formParams;
        }
        if (isOperatoreProvinciale !== undefined) {
            formParams = formParams.append('isOperatoreProvinciale', <any>isOperatoreProvinciale) || formParams;
        }
        if (isDelegatoRespo !== undefined) {
            formParams = formParams.append('isDelegatoRespo', <any>isDelegatoRespo) || formParams;
        }
        if (isLegaleRappresentante !== undefined) {
            formParams = formParams.append('isLegaleRappresentante', <any>isLegaleRappresentante) || formParams;
        }
        if (isPersonaAutorizzata !== undefined) {
            formParams = formParams.append('isPersonaAutorizzata', <any>isPersonaAutorizzata) || formParams;
        }
        if (emailRuolo !== undefined) {
            formParams = formParams.append('emailRuolo', <any>emailRuolo) || formParams;
        }

        return this.httpClient.post<string>(`${this.basePath}/comunicazione/upload-comunicazioni`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public verificaDatore1(body?: WrapperComunicazione, observe?: 'body', reportProgress?: boolean): Observable<Datore>;
    public verificaDatore1(body?: WrapperComunicazione, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Datore>>;
    public verificaDatore1(body?: WrapperComunicazione, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Datore>>;
    public verificaDatore1(body?: WrapperComunicazione, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Datore>(`${this.basePath}/comunicazione/verificaDatore`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
